<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>
  File: RubyCocoa Programming
  
    &mdash; RubyCocoa Documentation
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!file.programming.html";
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: RubyCocoa Programming</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'>
<h1 id="label-RubyCocoa+Programming">RubyCocoa Programming</h1>

<h2 id="label-irb+-+Interactive+Ruby">irb - Interactive Ruby</h2>

<p>You may want to use <code>irb</code> to try the script snippets in this
document. <code>irb</code> is a command that lets you use a Ruby
interpreter interactively from the command line. You can start an
interactive session with RubyCocoa using the following command:</p>

<pre class="code ruby"><code class="ruby">% irb -r osx/cocoa</code></pre>

<p>(NOTE) In Mac OS X 10.9, use
/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/irb.</p>

<h2 id="label-Load+libraries">Load libraries</h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>osx/cocoa</span><span class='tstring_end'>&#39;</span></span>      <span class='comment'># classes defined in Foundation and AppKit.
</span></code></pre>

<p>or</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>osx/foundation</span><span class='tstring_end'>&#39;</span></span> <span class='comment'># classes defined in Foundation
</span><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>osx/appkit</span><span class='tstring_end'>&#39;</span></span>     <span class='comment'># classes defined in AppKit
</span></code></pre>

<h2 id="label-A+first+example+with+sensory+appeal">A first example with sensory appeal</h2>

<p>Let&#39;s start with a simple example that will delight your senses – this
script will play a sound. Try this with [irb]:</p>

<pre class="code ruby"><code class="ruby">include OSX
files = `ls /System/Library/Sounds/*.aiff`.split
NSSound.alloc.initWithContentsOfFile_byReference (files[0], true).play
NSSound.alloc.initWithContentsOfFile_byReference (files[1], true).play
NSSound.alloc.initWithContentsOfFile_byReference (files[2], true).play</code></pre>

<h2 id="label-Cocoa+classes+are+Ruby+classes">Cocoa classes are Ruby classes</h2>

<p>In the following code examples, the comments starting with <code>#
=&gt;</code> show the string Ruby will output when it executes that line of
code.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSObject</span> <span class='comment'># =&gt; OSX::NSObject
</span><span class='id identifier rubyid_nsstr'>nsstr</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSObject</span><span class='period'>.</span><span class='id identifier rubyid_description'>description</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_nsstr'>nsstr</span>         <span class='comment'># =&gt; #&lt;OSX::OCObject:0x5194e8 class=&#39;NSCFString&#39; id=A97910&gt;
</span><span class='id identifier rubyid_nsobj'>nsobj</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSObject</span><span class='period'>.</span><span class='id identifier rubyid_alloc'>alloc</span><span class='period'>.</span><span class='id identifier rubyid_init'>init</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_nsobj'>nsobj</span>         <span class='comment'># =&gt; #&lt;OSX::NSObject:0x51f5b4 class=&#39;NSObject&#39; id=976D90&gt;
</span></code></pre>

<p>In RubyCocoa, a Cocoa class is defined as a Ruby class under the
<code>OSX</code> module. A Cocoa class is a Ruby class and behaves as a
Cocoa object.</p>

<h2 id="label-Creating+a+Cocoa+object">Creating a Cocoa object</h2>

<p>The normal Cocoa methods are used for creation of Cocoa objects.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_obj'>obj</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSObject</span><span class='period'>.</span><span class='id identifier rubyid_alloc'>alloc</span><span class='period'>.</span><span class='id identifier rubyid_init'>init</span>
<span class='id identifier rubyid_str'>str</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSString</span><span class='period'>.</span><span class='id identifier rubyid_stringWithString'>stringWithString</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_str'>str</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSString</span><span class='period'>.</span><span class='id identifier rubyid_alloc'>alloc</span><span class='period'>.</span><span class='id identifier rubyid_initWithString'>initWithString</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>world</span><span class='tstring_end'>&quot;</span></span>
</code></pre>

<p>Inside RubyCocoa, the created Cocoa object is wrapped in the object of a
class called <code>OSX::ObjcID</code>. Usually, you don&#39;t need to be
conscious of the existence of an <code>OSX::ObjcID</code> class.</p>

<h2 id="label-Ownership+and+memory+management">Ownership and memory management</h2>

<p>The instance of <code>OSX::ObjcID</code> is the real owner of the Cocoa
object which <code>self</code> has wrapped. Ownership is automatically lost
when the instance of <code>OSX::ObjcID</code> is cleaned by Ruby&#39;s
garbage collection. Therefore, it is not necessary to worry about memory
management issues such as ownership in RubyCocoa.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_str'>str</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSString</span><span class='period'>.</span><span class='id identifier rubyid_stringWithString'>stringWithString</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_str'>str</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSString</span><span class='period'>.</span><span class='id identifier rubyid_alloc'>alloc</span><span class='period'>.</span><span class='id identifier rubyid_initWithString'>initWithString</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>world</span><span class='tstring_end'>&quot;</span></span>
</code></pre>

<p>Although in Objective-C the two lines above differ as to whether ownership
is generated or delegated, in RubyCocoa there is no need to be conscious of
ownership; the difference between the two techniques shown above is not
such an important issue. In principle, it is not necessary to call methods
such as <code>release</code>, <code>autorelease</code>, and
<code>retain</code>, and you do not need to create
<code>NSAutoreleasePool</code>s.</p>
<ul><li>
<p>Use Cocoa methods to create Cocoa objects.</p>
</li><li>
<p>Don&#39;t worry about ownership and memory management.</p>
</li></ul>

<h2 id="label-Return+value+of+methods">Return value of methods</h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_nstr'>nstr</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSString</span><span class='period'>.</span><span class='id identifier rubyid_description'>description</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_nstr'>nstr</span>      <span class='comment'># =&gt; #&lt;OCObject:0x7233e class=&#39;NSCFString&#39; id=687610&gt;
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_nstr'>nstr</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span> <span class='comment'># =&gt; &quot;NSString&quot;
</span>
<span class='id identifier rubyid_nstr'>nstr</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSString</span><span class='period'>.</span><span class='id identifier rubyid_stringWithString'>stringWithString</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello World !</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_nstr'>nstr</span>      <span class='comment'># =&gt; #&lt;OCObject:0x71970 class=&#39;NSCFString&#39; id=688E90&gt;
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_nstr'>nstr</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span> <span class='comment'># =&gt; &quot;Hello World !&quot;
</span>
<span class='id identifier rubyid_nstr'>nstr</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSString</span><span class='period'>.</span><span class='id identifier rubyid_stringWithString'>stringWithString</span><span class='lparen'>(</span><span class='backtick'>`</span><span class='tstring_content'>pwd</span><span class='tstring_end'>`</span></span><span class='period'>.</span><span class='id identifier rubyid_chop'>chop</span><span class='rparen'>)</span>
<span class='id identifier rubyid_nary'>nary</span> <span class='op'>=</span> <span class='id identifier rubyid_nstr'>nstr</span><span class='period'>.</span><span class='id identifier rubyid_pathComponents'>pathComponents</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_nary'>nary</span>      <span class='comment'># =&gt; #&lt;OCObject:0x6bb2e class=&#39;NSCFArray&#39; id=3C0150&gt;
</span>
<span class='id identifier rubyid_ary'>ary</span> <span class='op'>=</span> <span class='id identifier rubyid_nary'>nary</span><span class='period'>.</span><span class='id identifier rubyid_to_a'>to_a</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_ary'>ary</span>       <span class='comment'># =&gt; [#&lt;OCObject:0x6a9b8 class=&#39;NSCFString&#39; id=3C2B50&gt;,...]
</span>
<span class='id identifier rubyid_ary'>ary</span><span class='period'>.</span><span class='id identifier rubyid_map!'>map!</span> <span class='lbrace'>{</span><span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span> <span class='rbrace'>}</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_ary'>ary</span>       <span class='comment'># =&gt; [&quot;/&quot;, &quot;Users&quot;, &quot;hisa&quot;, &quot;src&quot;, &quot;ruby&quot;, &quot;osxobjc&quot;]
</span></code></pre>

<p>In RubyCocoa, methods that return Objective-C objects such as
<code>NSString</code> and <code>NSArray</code> return Cocoa objects, as you
might have guessed from these examples. The return value is not
automatically converted to the corresponding Ruby class
(<code>String</code>, for example). For <code>NSString</code> and
<code>NSArray</code>, <code>to_s</code> and <code>to_a</code> are defined
and can be used.</p>

<h2 id="label-Representing+Objective-C+message+selectors">Representing Objective-C message selectors</h2>

<pre class="code ruby"><code class="ruby"><span class='comment'># play system sounds (2)
</span><span class='id identifier rubyid_sndfiles'>sndfiles</span><span class='period'>.</span><span class='id identifier rubyid_each'>each</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_path'>path</span><span class='op'>|</span>
  <span class='id identifier rubyid_snd'>snd</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSSound</span><span class='period'>.</span><span class='id identifier rubyid_alloc'>alloc</span><span class='period'>.</span><span class='id identifier rubyid_initWithContentsOfFile'>initWithContentsOfFile</span><span class='lparen'>(</span><span class='id identifier rubyid_path'>path</span><span class='comma'>,</span> <span class='symbol'>:byReference</span><span class='comma'>,</span> <span class='kw'>true</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_snd'>snd</span><span class='period'>.</span><span class='id identifier rubyid_play'>play</span>
  <span class='id identifier rubyid_sleep'>sleep</span> <span class='float'>0.25</span> <span class='kw'>while</span> <span class='id identifier rubyid_snd'>snd</span><span class='period'>.</span><span class='id identifier rubyid_isPlaying?'>isPlaying?</span>
<span class='kw'>end</span>
</code></pre>

<p>This is another version of “playing system sounds”. This shows the other
way Objective-C message selectors can be represented in the Ruby world.</p>

<p>In Objective-C:</p>

<pre class="code ruby"><code class="ruby">[obj hogeAt: a0 withParamA: a1 withParamB: a2]</code></pre>

<p>RubyCocoa provides several ways to specify message selectors. The simplest
way is to substitute “<code>:</code>” with “<code>_</code>”.</p>

<pre class="code ruby"><code class="ruby">obj.hogeAt_withParamA_withParamB_ (a0, a1, a2)</code></pre>

<p>But because this looks awkward, you can omit the last underscore.</p>

<pre class="code ruby"><code class="ruby">obj.hogeAt_withParamA_withParamB (a0, a1, a2)</code></pre>

<p>When the method name is very long, the relationship between the message
selector keyword and each argument is unclear. In order to improve this:</p>

<pre class="code ruby"><code class="ruby">obj.hogeAt (a0, :withParamA, a1, :withParamB, a2)</code></pre>

<p>For Cocoa methods that return the <code>BOOL</code> type (predicate
method), use the method name suffix “?” to return a Ruby boolean. If this
suffix is omitted, the method will return the value <code>0</code> (NO) or
<code>1</code> (YES). These values behave as <code>true</code> in the Ruby
world, so you will get unexpected results.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_nary'>nary</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSMutableArray</span><span class='period'>.</span><span class='id identifier rubyid_alloc'>alloc</span><span class='period'>.</span><span class='id identifier rubyid_init'>init</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_nary'>nary</span><span class='period'>.</span><span class='id identifier rubyid_containsObject'>containsObject</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hoge</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>   <span class='comment'># =&gt; 0
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_nary'>nary</span><span class='period'>.</span><span class='id identifier rubyid_containsObject?'>containsObject?</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hoge</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>  <span class='comment'># =&gt; false
</span><span class='id identifier rubyid_nary'>nary</span><span class='period'>.</span><span class='id identifier rubyid_addObject'>addObject</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hoge</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_nary'>nary</span><span class='period'>.</span><span class='id identifier rubyid_containsObject'>containsObject</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hoge</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>   <span class='comment'># =&gt; 1
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_nary'>nary</span><span class='period'>.</span><span class='id identifier rubyid_containsObject?'>containsObject?</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hoge</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>  <span class='comment'># =&gt; true
</span></code></pre>

<h2 id="label-Convert+Ruby+object+method+arguments+when+possible">Convert Ruby object method arguments when possible</h2>

<p>It seems to be usual containsObject of the top and, in case of method to
catch Objective-C object as a value of argument, tries conversion even if
it just hands Ruby object so long as it is possible.</p>

<h2 id="label-Handling+method+name+conflicts">Handling method name conflicts</h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_klass'>klass</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSObject</span><span class='period'>.</span><span class='id identifier rubyid_class'>class</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_klass'>klass</span>     <span class='comment'># =&gt; OSX::OCObject
</span><span class='id identifier rubyid_klass'>klass</span> <span class='op'>=</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSObject</span><span class='period'>.</span><span class='id identifier rubyid_oc_class'>oc_class</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_klass'>klass</span>     <span class='comment'># =&gt; #&lt;OCObject:0x82f22 class=&#39;NSObject&#39; id=80819B0C&gt;
</span></code></pre>

<p>When the same method name exists in Ruby and Objective-C, like in the case
of <code>Object#class</code>, prefix the method name with
“<code>oc_</code>”.</p>

<h2 id="label-Inheriting+from+Cocoa">Inheriting from Cocoa</h2>

<p>So far, we&#39;ve discussed existing Cocoa classes and their instances.
From this point, we&#39;ll discuss the definition and instantiation of
derived class of Cocoa, which is also needed when writing RubyCocoa
applications. Since the implementation of derived class mechanism for
RubyCocoa is a little tricky, there are some restrictions and
peculiarities.</p>

<h2 id="label-Defining+a+Cocoa-inherited+class">Defining a Cocoa-inherited class</h2>

<p>The class of the Cocoa objects set up in the GUI definition file (nib file)
created by Interface Builder is defined as an inherited class (after
0.2.0). For example, the Controller of the MVC model as described in many
Cocoa tutorials is defined in Ruby like this:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>AppController</span> <span class='op'>&lt;</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSObject</span>

  <span class='id identifier rubyid_ib_outlets'>ib_outlets</span> <span class='symbol'>:messageField</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_btnClicked'>btnClicked</span><span class='lparen'>(</span><span class='id identifier rubyid_sender'>sender</span><span class='rparen'>)</span>
    <span class='ivar'>@messageField</span><span class='period'>.</span><span class='id identifier rubyid_setStringValue'>setStringValue</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Merry Xmas !</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>end</span>

<span class='kw'>end</span>
</code></pre>

<p>The inherited class definition of Cocoa in RubyCocoa is similarly described
to be the inherited class definition by the usual Ruby in this way.</p>

<h2 id="label-Defining+Interface+Builder+outlets">Defining Interface Builder outlets</h2>

<p>The outlet set as the class in the nib file is written to be:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_ns_outlets'>ns_outlets</span> <span class='symbol'>:rateField</span><span class='comma'>,</span> <span class='symbol'>:dollerField</span>
</code></pre>

<p>in the definition of an inherited class. In fact, <code>ns_outlets</code>
is the same as <code>Module#attr_writer</code>. Therefore, a definition can
alternatively be given this way:</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>def</span> <span class='id identifier rubyid_rateField='>rateField=</span> <span class='lparen'>(</span><span class='id identifier rubyid_new_val'>new_val</span><span class='rparen'>)</span>
  <span class='ivar'>@rateField</span> <span class='op'>=</span> <span class='id identifier rubyid_new_val'>new_val</span>
<span class='kw'>end</span>
</code></pre>

<p><code>ns_outlets</code> also has an alias called <code>ib_outlets</code>.</p>

<h2 id="label-Overriding+a+method">Overriding a method</h2>

<p>When overriding a method defined by the parent class, it is necessary to
declare the override using <code>ns_overrides</code> (alias
<code>ib_overrides</code>).</p>

<pre class="code ruby"><code class="ruby">class MyCustomView &lt; OSX::NSView

  ns_overrides :drawRect_, &#39;mouseUp:&#39;

  def drawRect(frame)
  end

  ...
end</code></pre>

<p>In the argument of <code>ns_overrides</code> what expressed the message
selector of Objective-C as the string or the symbol is given. However, the
notation for omitting “:” and “_” of the end explained previously cannot be
used. It is necessary to describe correctly according to the number of
arguments.</p>

<p>To invoke the superclass method in an overriding method, prefix the method
name with “<code>super_</code>”.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>MyCustomView</span> <span class='op'>&lt;</span> <span class='const'>OSX</span><span class='op'>::</span><span class='const'>NSView</span>

  <span class='id identifier rubyid_ns_overrides'>ns_overrides</span> <span class='symbol'>:drawRect_</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_drawRect'>drawRect</span> <span class='lparen'>(</span><span class='id identifier rubyid_frame'>frame</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_frame'>frame</span>
    <span class='id identifier rubyid_super_drawRect'>super_drawRect</span><span class='lparen'>(</span><span class='id identifier rubyid_frame'>frame</span><span class='rparen'>)</span>   <span class='comment'># invoke the implementation of NSView#drawRect
</span>  <span class='kw'>end</span>

<span class='kw'>end</span>
</code></pre>

<h2 id="label-Instantiating+a+Cocoa-inherited+class">Instantiating a Cocoa-inherited class</h2>

<p>When an instance of a Cocoa-inherited class needs to be created in a Ruby
script, it writes like:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>AppController</span><span class='period'>.</span><span class='id identifier rubyid_alloc'>alloc</span><span class='period'>.</span><span class='id identifier rubyid_init'>init</span>  <span class='comment'># use this
</span></code></pre>

<p>like the case of the existing Cocoa class. The usual Ruby idiom:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>AppController</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>    <span class='comment'># don&#39;t use this
</span></code></pre>

<p>cannot be used (it raises an exception). Although there are various
situations in this, since it becomes long, a detailed explanation is
omitted here.</p>

<p>These restrictions have deep relation in instance generation being
performed in the turn:</p>
<ul><li>
<p>alloc (in Objective-C world)</p>
</li><li>
<p>in alloc, create a Ruby object (initialize method is called here)</p>
</li></ul>

<h2 id="label-Where+should+initialization+code+be+written-3F">Where should initialization code be written?</h2>

<p>In Ruby an initialization procedure is written in the
“<code>initialize</code>” method generally. But you should be careful in
doing so. When the “initialize” method is invoked, a Cocoa object in the
Objective-C space is just only given memory. And it is not initialized yet.
Therefore, in the “initialize” method, you must not invoke a method
implemented in Objective-C space. You should use only a method by Ruby at
the point.</p>

<p>If the object needs to be loaded from a nib file, initializing by the
“awakeFromNib” method is safest. Doesn&#39;t it seem that it is also
necessary to actually define the inherited class of Cocoa in most of these
cases?</p>

<p>In other cases, initialization is done in the style of Cocoa&#39;s
<code>init</code>. It is probably a good idea to write to a method with a
prefix.</p>

<p>Please do not forget to return <code>self</code> from initialization
methods.</p>
</div></div>

    <div id="footer">
  Generated on Sun May 31 11:56:30 2015 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.6 (ruby-2.2.2).
</div>

  </body>
</html>